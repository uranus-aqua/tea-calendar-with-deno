/**
 * @copyright 2023 KUO Wei-Shiung
 * @license MIT
 */
export class Teac {
  constructor(t) {
    void 0 === Teac.bM[0] && Teac.init(), Teac.cC(t);
  }
  static lD =
    '2IIn64o841o6KlE3kE3GmE4mHn6DBFJ2jCB4mE4l7Dl54n6DBJl5F52BKGl64n6Dl5AB4m6JoHGGl6A&Jk6AB3/FD/m63o8A/652B3/lE4/Aj/6CB/53/43/k5/42';
  static mD =
    '½½ïÃ3å3¼¿ÏÒf5½½ÙëÍ8ÐÀðÚíÍíá8çÀñÂÂØàÂå52aÊ8ÑÙÒÚ8ÐèéÜØøùÅÄ¿8ç6çÃ1ñòÑÅÙÈfêÅÙÀ¾ÍÔ÷ÜÉ¿ÑôhôÜóÎÆÆÂÛãîÆ6çÃß×ãîÕÉÂäõÊ5½îÕÉÈêÚÀÒ×ÍÔÞ1É½×êÚÞÎ1ÉÐôaÝÀØ1óÓ¼ÆÂÈ1óÖÂòÅãîèÇÖÒêÚÀð×fhÀÞÎÅÊ5½fÆÞÎÏâ6çÂåÑÏÖÂäåßÏëßßÙÖèÇÖúÊ8hâÀìáâöÂÈàÀÂäåÑÏëÍÙëÊ8hôÜúêfÜØÎáÆöòïõÑÙèÙëÍéÜÌÄøââÜñ8çå3ñòÑï2aêÅÙÒÚ÷æÑ1Ý½ÚæãÎùîÄ¿8&ðÍÜì/ÆâÂÛÑ/×ÚæÑÎ/éÆèé/ÆØàÂ/28528/8½/É¿ã/Èß/ØÅá/Þ×/àÀä/1¿É/æ16ÄÎ/ÌÄÎ/ÖÈ/Êa/8¿/ÒÍ/45/ÆÛ/46/¾5/3¿¼/8Ý/ÅÆ/ÅÏ/3Ã/Ì8/25/ÆÀ/ÌÕ/fÔ/ÄÐ/ÂË/1Ã/ÓÉ/Ê1/a½/1½/ÀÈ/3Ë/¿Ç/ÅÇ/Á½/ff/À6/¼½/32/61/ÂÃ/Ä¼/8¼/Á¿/3½/48/¾3/1¼/¾1/41/66/23/43';
  static nD =
    '928DEPB0NGMCA17EA039NKILKJB1zA117ELBCPFAAOAKMAKJLGELAAFMJFLADAPFEPDD2OOEGM0NGINAILAIFNIDCPAEM1070NGMCAMACMAKBLAJLKABLJ017LEBALFAKOBANDKALGANG12zDMAFLIEAPDC28FEIOCGMCAMAC128NKID1zIBNABCPBELBACMAKOBAJLKALGJFLA107LAFA&29/08/09/18/19/209/029/129/218/219/018/019/108/109/118/119';
  static dC(t, s) {
    const e = t.split('&'), n = new Map();
    return e[1].split('/').forEach((t) => {
      n.set(String.fromCodePoint(s--), t);
    }),
      n.forEach((t, s) => {
        e[0] = e[0].replaceAll(s, t);
      }),
      e[0].split('');
  }
  static nY = new Map();
  static sN() {
    const t = this.dC(this.nD, 80);
    let s = 1584, e = 4;
    this.nY.set(s - 1, 24),
      t.forEach((t) => {
        const n = 'z' === t ? 20 : Number(t) + 10;
        e += n < 15 ? -n : n, this.nY.set(s++, e + 20);
      });
  }
  static mC = new Array(6419);
  static sM() {
    const t = this.dC(this.mD, 250), s = new Array(2439).fill([1, 0]).flat();
    this.mC = [...s];
    const e = t.map((t) => parseInt(t, 32));
    let n = 0;
    e.forEach((t) => {
      n += t, this.mC.splice(n, 0, this.mC[n - 1]);
    });
  }
  static bM = new Array(12);
  static lP = new Map();
  static sL() {
    const t = this.dC(this.lD, 75);
    let s = 1580;
    t.forEach((t, e) => {
      const n = parseInt(t, 32), a = n < 14 ? 0 : -1;
      s += 3 + a, this.lP.set(s, [e, n + 13 * a]);
    });
  }
  static mL = new Map();
  static gL(t) {
    const s = this.mL.get(t);
    if (s) return s;
    const e = this.lP.get(t);
    let n = 12 * (t - 1582);
    n += e ? e[0] : ((t) => {
      if (1582 === t) return 0;
      const s = [];
      for (let e = 1; e < 4; e++) {
        const n = this.lP.get(t - e);
        n && s.push(n[0]);
      }
      return Math.max(...s) + 1;
    })(t);
    const a = e ? 13 : 12, i = this.mC.slice(n, n + a);
    let r = 0;
    return ((s, e) => {
      const n = new Array(e);
      return s.forEach((t, s) => {
        r += 29 + Number(t), n[s] = r;
      }),
        this.mL.set(t, n),
        n;
    })(i, a);
  }
  static mN = new Map();
  static gM(t) {
    const s = this.mN.get(t);
    if (s) return s;
    const e = this.bM.map((t) => t), n = this.lP.get(t);
    return n && e.splice(n[1], 0, `${n[1]}bis`), this.mN.set(t, e), e;
  }
  static rS = new Array(4);
  num() {
    return Teac.rS;
  }
  static cC(t) {
    const s = new Date(t + 'T12:00:00.000Z');
    if (isNaN(s)) return 'N/A';
    let e = t.length > 9 ? Number(t.slice(0, 4)) : null;
    if (e > 2100 || e < 1583) return 'N/A';
    const n = new Date(`${e}-01-01T12:00:00.000Z`),
      a = Math.floor((s - n) / 864e5) + 1 - this.nY.get(e) + 1,
      i = a < 1;
    e -= i ? 1 : 0;
    const r = this.gL(e);
    let c, h, l;
    if (i) {
      const t = r.length;
      l = a + (r[t - 1] - r[t - 2]),
        c = l > 0 ? t - 1 : t - 2,
        l = l > 0 ? l : l + r[t - 2] - r[t - 3];
    } else {c = Math.floor(a / 32),
        c += a < this.gL(e)[c] + 1 ? 0 : 1,
        l = 0 === c ? a : a - r[c - 1];}
    h = this.gM(e)[c];
    const o = 'string' == typeof h;
    h = o ? Number(h.slice(0, -3)) : h;
    const A = (e - 1563) % 60 || 60;
    this.rS = [A, h, l, o];
  }
  yearIn(t = null) {
    if (null !== t) return Lang.yearIn(t);
  }
  sino(t = null, s) {
    if (null !== t) return Lang.sino(t, s);
  }
  static {
    this.sN(),
      this.sM(),
      this.sL(),
      this.bM = Array.from({ length: 12 }, (t, s) => s + 1);
  }
}
export class Lang {
  static yS = new Map();
  static mS = new Map();
  static dS = new Map();
  static sY(t, s) {
    const e = new Date(s + 1983, 1),
      n = new Intl.DateTimeFormat(t, { year: 'numeric', calendar: 'chinese' })
        .formatToParts(e).filter((t) => 'yearName' === t.type)[0].value;
    return this.yS.set(`${t}${s}`, n), n;
  }
  static sS(t) {
    const s = new Intl.NumberFormat('zh-Hans-TW-u-nu-hanidec').format;
    for (let e = 1; e < 13; e++) {
      this.mS.set(
        e,
        `${e > 9 ? '十' : ''}${1 !== e || t ? 10 != e ? s(e % 10) : '' : '正'}`,
      );
    }
    for (let t = 1; t < 31; t++) {
      this.dS.set(
        t,
        `${
          t > 19 && t % 10 == 0
            ? s(Math.floor(t / 10))
            : t > 20
            ? '廿'
            : t > 10
            ? '十'
            : '初'
        }${t % 10 == 0 ? '十' : s(t % 10)}`,
      );
    }
  }
  static yearIn(t) {
    const s = Teac.rS[0], e = this.yS.get(`${t}${s}`) || this.sY(t, s);
    return Teac.rS.with(0, e);
  }
  static sino(t = 0, s = !0) {
    !this.dS.get(1) && this.sS(Teac.rS[3]);
    const e = ['年', '月'];
    return [
      `${this.yearIn('zh')[0]}${s ? e[0] : ''}`,
      `${Teac.rS[3] ? ['閏', '闰'][t] : ''}${this.mS.get(Teac.rS[1])}${
        s ? e[1] : ''
      }`,
      `${this.dS.get(Teac.rS[2])}`,
    ];
  }
}
